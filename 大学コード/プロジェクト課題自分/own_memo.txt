TUVW:0~3番目の対局者のツモ,DEFG:0~3番目の対局者のツモ
feature_val_cal.py-> 赤牌の区別まだできてない
z->z1東z2南z3西z4北z5白z6發z7中
未実装だけど赤はp0


"統一させる決まり"
・特徴量計算の関数での出力はリスト、各関数で出力したものを最後に合体させるときに行列にする
・



"各プログラムの概要"
・second_process.py->入力データから初期手牌とツモ・捨て牌のデータ抽出
                     [{'hai0': '91,124,49,2,59,44,100,32,77,63,29,27,76', 
                       'discards_before_reach': ['T135', 'D2', 'U51', 'E118', ~(省略)~, 'G121', 'T106']}]
・feature_val_cal.py->secon_process.pyのから手牌データ抽出、可視化できるよう加工
                     ex.['m2', 'm2', 'm5', 'm6', 'm7', 'm8', 'p1', 'p1', 'p3', 'p4', 'p7', 'p9', 's4']
                     その後特徴量の計算する関数を記述
                     ex.七対子の向聴数4<-ここではわかりやすいような出力()
・ex_change_characters.py->入力層に入力できるようなベクトルへの変換
                           feature_val_ca.pyで各特徴量を計算してここにもってくる
                           ex.[0,0,0,~(計432次元)~1,0,1]  
・update_hand.py->second_process.pyから"haix:~~~"と"discards_before_reach:~~~"を読み込んで
                　１巡後の手牌の出力を行う。これで複数のデータに対して特徴量の計算が可能                  
                  ex.[91, 124, 49, 2, 59, 44, 100, 32, 77, 63, 29, 27, 76, 135]とD2,T115から
                  [91, 124, 49, 59, 44, 100, 32, 77, 63, 29, 27, 76, 135, 115]を次の配列要素として格納
・feature_val_cal->これメイン。今までのファイル全部読み込んで実行していく。
                   update_hand.pyとexchange_characters.pyから各ベクトルを多次元リストとして出力
・average_perceptron.py->平均化パーセプトロンの作成                   


・calculate_yakuhai_feature.py->特徴量（字牌の枚数、役、ドラ）引数




・通常手向聴数 = 8 -(面子数)*2 - (面子候補数)
  面子過多にならないようにmax{(面子数)+(面子候補数)}=4
  1,1,1,2,3,4->面子を優先してとる。(面子候補)を優先順位低い。
  
  For すべての雀頭候補について
　　それを雀頭と仮定する
　　数牌の種類ごとに、
　　A：「面子×２ ＋ 面子候補」が最大となる面子・面子候補を選ぶ
　　B：「面子×１０ ＋ 面子候補」が最大となる面子・面子候補を選ぶ
　　それらの組み合わせの中で、向聴数が最少となるものを探す
　End

この処理を基本とするが、処理効率の部分で孤立牌の除去したい。








2 4 8 10 14 15 18 20 22 22 25 30 31 32 4 8 5

mpsz
m1,m2,m3,,m3,m4,m4,m5,m6,m6,m6,m7,m8,m8,m9